---
title: 'React 렌더링 (1)'
category: '리액트'
excerpt: '리액트에서 렌더링이란 어떤 것을 의미할까요? 렌더링이란 다양한 레벨에서 사용되는 추상적인 개념이지만 이미지를 그려내는 과정, 즉 리액트에서 렌더링이란 화면에 특정한 요소를 그려내는 것을 의미합니다. 리렌더링의 프로세스가 복잡해지거나 빈도가 잦으면 그에 따른 실행 비용이 올라가고 결국 퍼포먼스의 저하로 이어지게 됩니다.'
description: '리액트에서 언제 리렌더가 발생할까?'
tags: '렌더링, 상태'
date: '2022-11-23'
---

## 렌더링이란?

&emsp;리액트에서 렌더링이란 어떤 것을 의미할까요? 렌더링이란 다양한 레벨에서 사용되는 추상적인 개념이지만 이미지를 그려내는 과정, 즉 리액트에서 렌더링이란 화면에 특정한 요소를 그려내는 것을 의미합니다. 브라우저에서 HTML과 CSS를 파싱하여 DOM요소를 계산하고 그리면 개발자는 화면에서 보여줄 UI를 **선언**하기만 하고 DOM API와 Javascript를 통해 사용자에게 보일 화면을 변화시킵니다. 애플리케이션 규모가 커짐에 따라 UI관리가 어려운 Vanilla Javascript를 이용한 명령형의 DOM에 대한 조작보다는 리액트와 같이 선언적이고 컴포넌트 기반의 라이브러리나 프레임워크를 통해 실제 렌더링 과정을 최적화된 방법으로 대신 처리해 주고 개발자에게 UI를 설계하는 데만 집중하게 해주는 것이 리액트의 가장 큰 매력이자 장점이라고 볼 수 있습니다.

<img src="/assets/markdown-image/React-렌더링-최적화-1/React_home.png" alt="리액트" width="860" height="260"/>

<span>1.1 React, https://reactjs.org/</span>

하지만 개발자는 사용자에게 보일 UI를 처리할 때 리액트 내부에서 동작하는 렌더링 과정을 최적화해야 합니다.

</br>

## 리액트에서 리렌더링 되는 시점

&emsp;렌더링은 사용자가 초기에 웹에 접근했을 때 발생합니다. 그렇다면 리액트에서 리렌더링은 언제 발생할까요? 리액트에서 리렌더링은 UI와 결합된 상태(state)가 업데이트될 때 발생되도록 하는 모델을 갖고 있습니다. 상태라는 것은 개발자 입장에서 관리해야 하는 데이터들, 즉 언제든지 사용자의 액션에 의해 변경될 여지가 있는 저장된 데이터를 의미합니다. 리렌더링이 발생하는 시점은 그 데이터가 <b>상태 업데이트 함수(setState)</b>를 통해 변경되었을 때 발생하게 됩니다. 특정 컴포넌트의 상태가 업데이트됐다면 해당 컴포넌트와 그 하위에 있는 모든 컴포넌트들은 리렌더링이 발생하게 됩니다. 따라서 상태가 변하면 해당 컴포넌트를 포함한 모든 자식 컴포넌트들이 리렌더링 된다는 리액트의 설계를 이해하는 것이 렌더링 최적화에 있어 기본이 되는 사항입니다.

</br>

## 리액트 렌더링 과정

&emsp;앞서 리액트는 상태가 업데이트됐을 때 리렌더링이 발생한다고 했는데 상태가 변경되고 변경 사항이 브라우저의 UI에 반영되기까지 내부적으로 크게 4가지 단계를 거치게 됩니다.

1. 기존 컴포넌트의 UI를 재사용할 지 확인한다.
2. 재사용 안한다? 함수 컴포넌트의 경우 컴포넌트 함수를 호출한다 즉 return 값
3. 2번의 결과를 통해서 새로운 Virtual DOM을 생성
4. 이전의 Virtual DOM과 새로운 Virtual DOM을 비교해서 **변경된 부분만 DOM**에 적용

상태 업데이트 함수를 호출할 때마다 위 네 가지 과정이 실행됩니다. 근데 큰 틀에서만 봤을 때도 복잡한 이 과정을 왜 거칠까요? 그냥 DOM에 접근해서 조작할 수는 없을까요? 왜 Virtual DOM을 쓸까요? 위 path는 리액트의 렌더링 과정이고 Virtual DOM을 왜 사용하는지에 대해 우선 브라우저의 렌더링 과정을 살펴보겠습니다. 브라우저는 기본적으로 화면을 보여주기 위해 HTML, CSS, JS를 다운로드 받고 파싱 한 후 화면에 픽셀 형태로 그려냅니다. 이 과정을 브라우저에서 **Critical Rendering Path**라고 부릅니다.

DOM을 바꿀 때 마다 브라우저는 기본적으로 Critical Rendering Path를 수행합니다.

1. HTML을 파싱해서 DOM 생성
2. CSS를 파싱해서 CSSOM 생성
3. DOM, CSSOM 결합해서 render tree 생성(스타일과 태그를 결합)
4. render tree와 viewport의 width를 통해서 각 요소들의 위치와 크기를 **계산**(Layout)
5. 계산된 정보를 이용해 Render Tree 요소들을 픽셀로 **그림**(Paint)

&emsp;Layout과 Paint과정은 간단하게 생각해 봐도 브라우저가 각 요소들이 화면상 어디에 출력될지 매번 계산하고 그 값들을 이용해서 픽셀점 하나하나 찍어주는 작업이기 때문에 브라우저에게 많은 연산을 요구하는 고비용의 프로세스입니다. UI를 변경하기 위해서는 많은 DOM 조작이 필요하고 매번 조작이 발생할 때마다 CRP가 수행되고 렌더링에 대한 고려 혹은 최적화가 이루어지지 않으면 당연히 퍼포먼스 저하로 연결됩니다. 렌더링 최적화라는 것은 결국 Critical Rendering Path의 최적화라고 볼 수 있습니다. 리액트는 이를 해결하고자 <b>Virtual DOM</b>을 사용합니다.

<img src="/assets/markdown-image/React-렌더링-최적화-1/VDOM.png" alt="Virtual DOM" width="700" height="450"/>

<span>1.2 React Virtual DOM Explained in Simple English, https://programmingwithmosh.com/react/react-virtual-dom-explained/</span>

&emsp;리액트에서는 UI 변화에 필요한 DOM 변경 사항들을 매번 즉각적으로 실제 DOM에 적용하는 것이 아니라 DOM과 유사한 Virtual DOM을 만들어 냅니다. 상태의 변화가 감지가 되면 Virtual DOM에 먼저 적용이 된 후 이전의 render tree와 새로운 render tree를 비교합니다. 변경 전의 Virtual DOM과 변경 후의 Virtual DOM을 비교하는 작업을 diffing이라고 합니다.

<!-- ```
diffing:
``` -->

&emsp;ReactDOM 라이브러리는 실제로 변화가 필요한 DOM 요소들을 찾아낸 후 한 번에 해당 DOM 요소들을 조작합니다. 리액트에서 이러한 메커니즘은 내부적으로 Virtual DOM을 유지하여 개발자를 대신해 CRP를 최적화, 즉 렌더링의 최적화를 이룹니다.

<!-- > reconciliation은 ~ -->

&emsp;그래서 렌더링 최적화는 당연히 중요하지만 왜 중요할까요? 리렌더링은 앞서 말했듯이 리액트 내부적으로 diffing 알고리즘을 통해 업데이트될 실제 DOM에 적용될 사항들을 파악하고 함수를 호출하는 작업을 실행한다고 설명했습니다. 당연히 리렌더링이 의도와는 다르게 또는 불필요하게 많이 발생한다면 함수가 계속 호출되고 return 문에 있는 값들이 반복적으로 실행됩니다. 리렌더링의 프로세스가 복잡해지거나 빈도가 잦으면 그에 따른 실행 비용이 올라가고 결국 퍼포먼스의 저하로 이어지게 됩니다.

React 렌더링 및 최적화 2부에서는 React.memo를 활용한 렌더링 최적화에 대해 알아보겠습니다. <a href="https://www.moonkorea.dev/React-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94-(2)-React-memo" target=”_blank”>2부 보러 가기</a>